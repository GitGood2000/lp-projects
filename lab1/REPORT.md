# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Катермин В.С.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Список - это абстрактный тип данных, используемый для хранения упорядоченного набора элементов. 

В языке Prolog списки совсем не похожи на те, которые мы наблюдали в империтвных языках. У них все элементы списка имеют одинаковый тип. В Prolog каждый элемент может быть чем угодно. В императивных языках для обращения к элементу используются итераторы. Prolog способен обрабатывать элементы только рекурсивно, разделяя список на голову (Head) и хвост (Tail).

Набор стандартных предикатов обработки списков наводит на мысль, что списки можно применять для представления множеств. Однако в множестве порядок элементов не существенен, а для списка порядок необходим, так как он имеет значение. Более того, список является мультимножеством - один и тот же объект может встретиться в списке несколько раз.

## Задание 1.1: Предикат обработки списка

`spec_away(index, list, list without an item)` - удаляет элемент по индексу.
(`spec_away_std(list, 1, index, [], list without an item)` - аналогично, с использованием стандартных предикатов.) 

Примеры использования:
```prolog
?- spec_away(1, [1, 1, 2, 3, 5], X).
X = [1,2,3,5]
yes
?- spec_away(5, [2, 4, 8, 16, 32, 64], X).
X = [2,4,8,16,64]
yes
?- spec_away(2, [4, 5, 1], X).
X = [4,1]
yes

?- spec_away_std([1,1,2,3,5,8], 1, 2, [], L).
L = [1,2,3,5,8] ? 
yes
?- spec_away_std([3],1,1,[],L).
L = []
yes
?- spec_away_std([1, 3],1,3,[],L).
L = [1,3] ? 
yes
```

Реализация:
```prolog
spec_away(_,[],[]).
spec_away(1,[_|T],Tail) :-!.
    I1 is I-1,
    spec_away(I1,Tail,NewTail).
    
spec_away_std([] ,_ ,_ ,M ,M):-!.
spec_away_std([H|T], Idx, N, L, List):-
    Idx < N,
    Idx1 = Idx + 1,
    append(L, [H], L2),
    spec_away_std(T, Idx1, N, L2, List).
 spec_away_std([H|T], Idx, N, L, List):-
    Idx > N,
    Idx1 = Idx + 1,
    append(L, [H], L2),
    spec_away_std(T, Idx1, N, L2, List).   
spec_away_std([_|T], Idx, N, L, List):-
    Idx = Idx + 1,
    spec_away_std(T, Idx1, N, L, List).
```

Реализация предиката spec_away(index, list, list without an item):
С помощью уникальной возможности Prolog разбивать список на 'голову' и 'хвост', раскладываем список так, чтобы выделить хвост списка после трех элементов. Этот хвост и является ответом.

Реализация предиката spec_away_std(list, 1, index, [], list without an item):
Перебираем список с помощью разбиения на 'голову' и 'хвост' и каждый элемент добавляется в пустой список, кроме элемента, который стоит на н-ой позиции.

## Задание 1.2: Предикат обработки числового списка

`v_sumall(list1, list2, result)` - сумма двух векторов-списков.
(`v_sumall_std(list1, list2, result)` - аналогично, с использованием стандартных предикатов.) 

Примеры использования:
```prolog
?- v_sumall([3, 2, 4], [2, 0], X).
X = 11
yes
?- v_sumall([4, 2], [4, 2], X).
X = 12
yes
?- v_sumall([1, 7, 3], [6, 15], X).
X = 32
yes

?- v_sumall_std([3, 2, 4], [2, 0], X).
X = 11
yes
?- v_sumall_std([4, 2], [4, 2], X).
X = 12
yes
?- v_sumall_std([1, 7, 3], [6, 15], X).
X = 32
yes
```

Реализация:
```prolog
v_sum([],0).
v_sum([H|T],Sum):-  
    v_sum(T,Sum1),  
    Sum=H+Sum1.

v_sumall([], [], 0).
v_sumall(X, Y, S) :-
    sum(X, A),
    sum(Y, B),
    S is A + B.
...
v_sumall_std([], [], 0).
v_sumall_std(X, Y, S) :-
    sum_list(X, A),
    sum_list(Y, B),
    S is A + B.
```

Реализация этих предикатов ничем не отличается кроме как собственной реализацией стандартного предиката sum_list: Считаем сумму элементов первого и второго вектора, затем просто суммируем эти два полученные числа.

## Задание 2: Реляционное представление данных

Типы моделей данных:
* Иерархическая модель 
* Сетевая модель 
* Реляционная модель 

В реляционной модели данных объекты и взаимосвязи между ними представляются с помощью таблиц. 
Взаимосвязи рассматриваются в качестве объектов.

Преимущества реляционного представления:

* удобное для пользователя представление объектов в виде таблиц
* возможность использования непроцедурных языков для работы 
* основа модели - математический аппарат, который позволяется строго описывать операции над данными
* независимость данных

Недостатки реляционного представления:

* не все необходимые для описания сферы можно представить в виде таблиц
* большой расход памяти для представления
* низкая скорость при выполнении операции соединения

Опишите принцип реализации всех предикатов, осуществляющих запросы к данным.

## Выводы

Сформулируйте *содержательные* выводы по лабораторной работе. Чему она вас научила? Над чем заставила задуматься? Помните, что несодержательные выводы -
самая частая причина снижения оценки за лабораторную.




